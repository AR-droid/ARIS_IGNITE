
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .hello-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-align: center;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Knowledge Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Graph Container */
        #graph {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5;
        }
        svg {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Graph Controls */
        .graph-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: 1px solid #ddd;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .control-btn:hover {
            background: #f0f0f0;
            transform: scale(1.1);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        #reset-view {
            font-size: 16px;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
        }
        #graph { 
            width: 100vw; 
            height: 100vh; 
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
        }
        .node { 
            cursor: pointer; 
            transition: all 0.3s ease;
        }
        .node circle { 
            stroke-width: 2px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .node circle.highlighted {
            stroke: #fff !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.8));
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { r: 90%; }
            50% { r: 100%; }
            100% { r: 90%; }
        }
        .node:hover circle {
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
        }
        .link { 
            stroke-opacity: 0.6;
            stroke-linecap: round;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .link.highlighted {
            stroke-opacity: 1 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        
        .link.faded {
            stroke-opacity: 0.1 !important;
        }
        .link:hover {
            stroke-opacity: 1;
            stroke-width: 2.5px;
        }
        .node text { 
            font-size: 12px; 
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            pointer-events: none;
            user-select: none;
            fill: white;
            paint-order: stroke;
            stroke: rgba(0,0,0,0.5);
            stroke-width: 2px;
        }
        
        .node text.highlighted {
            font-weight: 800;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(30, 30, 35, 0.95);
            color: #fff;
            border-radius: 8px;
            pointer-events: none;
            font-size: 13px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            transform: translate(-50%, 10px);
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 1000;
        }
        .tooltip.visible {
            opacity: 1;
            transform: translate(-50%, 0);
        }
        .tooltip h3 {
            margin: 0 0 6px 0;
            color: #64b5f6;
            font-size: 14px;
        }
        .tooltip p {
            margin: 4px 0;
            line-height: 1.4;
        }
        .tooltip .type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 6px;
            background: rgba(255,255,255,0.1);
        }
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 100;
            max-width: 220px;
        }
        .legend h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 6px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="hello-message">Knowledge Graph Visualization</div>
    <div id="graph"></div>
    <div id="tooltip" class="tooltip" style="display: none;"></div>
    
    <!-- Debug Info -->
    <div id="debug" style="position: fixed; bottom: 10px; left: 10px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 5px; font-family: monospace; z-index: 1000; max-width: 400px; max-height: 200px; overflow: auto; border: 1px solid #ddd;">
        <h4 style="margin: 0 0 10px 0; padding: 0;">Debug Info</h4>
        <pre id="debug-content" style="margin: 0; font-size: 12px; white-space: pre-wrap;">Loading debug information...</pre>
    </div>
    
    <!-- Zoom and Reset Controls -->
    <div class="graph-controls">
        <button id="zoom-in" class="control-btn" title="Zoom In">+</button>
        <button id="zoom-out" class="control-btn" title="Zoom Out">-</button>
        <button id="reset-view" class="control-btn" title="Reset View">⟲</button>
        <button id="fit-view" class="control-btn" title="Fit to Screen">⤢</button>
    </div>

    <script>
        // Color scheme for different node types
        const colorScheme = {
            'PAPER': '#4285F4',
            'AUTHOR': '#EA4335',
            'CONCEPT': '#34A853',
            'METHOD': '#FBBC05',
            'default': '#9E9E9E'
        };
        
        // D3.js version check
        console.log('D3.js version:', d3.version);
        
        // Debug info function
        function updateDebugInfo() {
            const debugInfo = {
                windowSize: { width: window.innerWidth, height: window.innerHeight },
                svgSize: svg ? { width: +svg.attr('width'), height: +svg.attr('height') } : 'No SVG',
                nodes: window.validNodes ? window.validNodes.length : 0,
                links: window.validLinks ? window.validLinks.length : 0,
                simulation: window.simulation ? 'Running' : 'Not running'
            };
            
            // Update debug display
            document.getElementById('debug-content').textContent = JSON.stringify(debugInfo, null, 2);
            
            // Log node positions if available
            if (window.validNodes && window.validNodes.length > 0) {
                console.log('Node positions:', window.validNodes.map(n => ({
                    id: n.id,
                    type: n.type,
                    x: n.x,
                    y: n.y,
                    size: n.size
                })));
            }
        }
        
        // Initialize D3.js visualization
        const width = window.innerWidth;
        const height = window.innerHeight;
        let selectedNode = null;
        
        // Create SVG container
        const svg = d3.select('#graph')
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .call(d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                }));
            
        // Create a group for the graph elements
        const g = svg.append('g');
        
        // Initialize graph data
        let graphData = { nodes: [], links: [] };
        
        // Initialize D3 force simulation
        let simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2));
            
        // Initialize tooltip
        const tooltip = d3.select('#tooltip');
        
        // Initialize graph elements
        let link, node, nodeText;
        
        // Initialize the graph
        function initGraph() {
            // Add arrow markers for each relationship type
            const defs = svg.append('defs');
            
            // Create arrow markers for each relationship type
            Object.entries({
                'CITES': '#ff7f0e',
                'AUTHORED_BY': '#e15759',
                'USES': '#59a14f',
                'COMPARES': '#9467bd',
                'IMPROVES': '#8c564b',
                'INTRODUCES': '#17becf',
                'EVALUATES': '#d62728',
                'DEMONSTRATES': '#bcbd22',
                'ACHIEVES': '#e377c2',
                'BASED_ON': '#7f7f7f',
                'EXTENDS': '#1f77b4',
                'AFFILIATED_WITH': '#ffbb78',
                'PUBLISHED_IN': '#aec7e8',
                'PRESENTS': '#98df8a',
                'ADDRESSES': '#c5b0d5',
                'default': '#c7c7c7'
            }).forEach(([type, color]) => {
                defs.append('marker')
                    .attr('id', `arrow-${type}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 25)
                    .attr('refY', 0)
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', color);
            });

            // Add gradient for nodes
            const gradient = defs.append('linearGradient')
                .attr('id', 'node-gradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '100%');
                
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#fff')
                .attr('stop-opacity', 0.8);
                
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#f0f0f0')
                .attr('stop-opacity', 0.8);

            // Initialize graph elements
            link = g.append('g').selectAll('.link');
            node = g.append('g').selectAll('.node');
            nodeText = g.append('g').selectAll('.node-text');

            // Add legend
            const legend = d3.select('body').append('div')
                .attr('class', 'legend');
                
            legend.append('h3')
                .text('Entity Types');
                
            const legendItems = legend.selectAll('.legend-item')
                .data(Object.entries(colorScheme))
                .enter()
                .append('div')
                .attr('class', 'legend-item');
                
            legendItems.append('div')
                .attr('class', 'legend-color')
                .style('background-color', d => d[1]);
                
            legendItems.append('span')
                .text(d => d[0]);
        }

        // Load paper graph data with error handling
        async function loadPaperGraph(paperId) {
            try {
            try {
                console.log('Loading graph for paper:', paperId);
                
                // Show loading state
                d3.select('#graph').html(`
                    <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
                        <div style="text-align: center;">
                            <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-3">Building knowledge graph for paper ${paperId}...</p>
                        </div>
                    </div>
                `);

                // Fetch knowledge graph data for the paper
                console.log('Fetching graph data from API...');
                const response = await fetch(`/api/knowledge-graph/paper/${paperId}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response from server:', errorText);
                    let errorMessage = 'Failed to load knowledge graph';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const graphData = await response.json();
                console.log('Received graph data:', graphData);
                
                if (!graphData) {
                    throw new Error('No data received from server');
                }
                
                // Ensure we have valid nodes and links arrays
                const nodes = Array.isArray(graphData.nodes) ? graphData.nodes : [];
                const links = Array.isArray(graphData.links) ? graphData.links : [];
                
                console.log(`Processing ${nodes.length} nodes and ${links.length} links`);
                
                if (nodes.length === 0 && links.length === 0) {
                    console.warn('Empty graph data received');
                    d3.select('#graph').html(`
                        <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
                            <div class="alert alert-warning">
                                <h4>No Graph Data</h4>
                                <p>No graph data available for this paper yet.</p>
                                <button class="btn btn-primary mt-2" onclick="window.location.reload()">Try Again</button>
                            </div>
                        </div>
                    `);
                    return;
                }
                
                // Log some sample data for debugging
                console.log('Sample nodes:', nodes.slice(0, 3));
                console.log('Sample links:', links.slice(0, 3));
                
                // Update the graph with the new data
                console.log('Updating graph visualization...');
                updateGraph({
                    nodes: nodes,
                    links: links
                });
                
                console.log(`Graph updated with ${nodes.length} nodes and ${links.length} links`);

            } catch (error) {
                console.error('Error loading paper graph:', error);
                d3.select('#graph').html(`
                    <div class="alert alert-danger" style="margin: 20px;">
                        <h4>Error loading paper</h4>
                        <p>${error.message || 'Failed to load paper data. Please try again.'}</p>
                        <button class="btn btn-primary mt-2" onclick="window.location.reload()">Retry</button>
                    </div>
                `);
            }
        }

        // Process graph data into nodes and links with proper types and relationships
        function processGraphData(data) {
            // Make nodes and links available globally for debugging
            window.rawGraphData = data;
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            const linkSet = new Set();
            
            // Helper to create a unique link key
            const linkKey = (source, target, type) => `${source}-${target}-${type}`;

            // Process nodes from the data
            if (data.nodes) {
                data.nodes.forEach(node => {
                    const nodeId = node.id;
                    const nodeType = (node.type || 'CONCEPT').toUpperCase();
                    
                    // Set node size based on type or use provided size
                    let nodeSize = node.size || 10;
                    if (nodeType === 'PAPER') nodeSize = 20;
                    else if (nodeType === 'AUTHOR') nodeSize = 16;
                    else if (nodeType === 'KEYWORD') nodeSize = 12;
                    
                    // Create enhanced node object
                    const enhancedNode = {
                        id: nodeId,
                        name: node.label || node.title || node.name || nodeId,
                        type: nodeType,
                        group: node.group || nodeType.toLowerCase(),
                        size: nodeSize,
                        color: node.color || getNodeColor(nodeType),
                        ...node // Include all original properties
                    };
                    
                    // Add type-specific properties
                    if (nodeType === 'PAPER') {
                        enhancedNode.year = node.year || new Date().getFullYear();
                        enhancedNode.citations = node.citations || 0;
                        enhancedNode.abstract = node.abstract || '';
                    } else if (nodeType === 'AUTHOR') {
                        enhancedNode.affiliation = node.affiliation || '';
                    }
                    
                    nodes.push(enhancedNode);
                    nodeMap.set(nodeId, enhancedNode);
                });
            }

            // Process concept network if present
            if (data.concept_network?.nodes) {
                data.concept_network.nodes.forEach(concept => {
                    const conceptId = `concept_${concept.id || concept.label.replace(/\s+/g, '_')}`;
                    const nodeType = 'CONCEPT';
                    
                    // Only add if not already in the node map
                    if (!nodeMap.has(conceptId)) {
                        const conceptNode = {
                            id: conceptId,
                            name: concept.label || concept.name || 'Concept',
                            type: nodeType,
                            group: 'concept',
                            size: 12,
                            color: getNodeColor(nodeType),
                            ...concept
                        };
                        
                        nodes.push(conceptNode);
                        nodeMap.set(conceptId, conceptNode);
                    }
                });
                
                // Add links from concept network
                if (data.concept_network.links) {
                    data.concept_network.links.forEach(link => {
                        const sourceId = `concept_${link.source}`;
                        const targetId = `concept_${link.target}`;
                        const key = linkKey(sourceId, targetId, 'RELATED_TO');
                        
                        if (nodeMap.has(sourceId) && nodeMap.has(targetId) && !linkSet.has(key)) {
                            links.push({
                                source: sourceId,
                                target: targetId,
                                type: 'RELATED_TO',
                                label: 'related to',
                                strength: link.strength || 0.3,
                                color: getLinkColor('RELATED_TO')
                            });
                            linkSet.add(key);
                        }
                    });
                }
            }
            
            // Process links with enhanced relationship handling
            if (data.links) {
                data.links.forEach(link => {
                    const sourceId = link.source;
                    const targetId = link.target;
                    const linkType = (link.type || 'RELATED_TO').toUpperCase();
                    const key = linkKey(sourceId, targetId, linkType);
                    
                    // Only process if both nodes exist and we haven't seen this link before
                    if (nodeMap.has(sourceId) && nodeMap.has(targetId) && !linkSet.has(key)) {
                        const sourceNode = nodeMap.get(sourceId);
                        const targetNode = nodeMap.get(targetId);
                        
                        // Determine link label based on type
                        const linkLabel = link.label || 
                            (linkType === 'AUTHORED_BY' ? 'authored by' : 
                             linkType === 'CITES' ? 'cites' :
                             linkType === 'RELATES_TO' ? 'relates to' :
                             linkType === 'CONTAINS_KEYWORD' ? 'contains' :
                             linkType === 'RESEARCHES' ? 'researches' : 'related to');
                        
                        // Calculate link strength based on type or use provided
                        let linkStrength = link.strength || 0.5;
                        if (linkType === 'AUTHORED_BY') linkStrength = 0.9;
                        else if (linkType === 'CITES') linkStrength = 0.8;
                        
                        // Add the link
                        links.push({
                            source: sourceId,
                            target: targetId,
                            type: linkType,
                            label: linkLabel,
                            strength: linkStrength,
                            color: link.color || getLinkColor(linkType),
                            curve: linkType === 'AUTHORED_BY' ? 0.2 : 0,
                            width: linkType === 'AUTHORED_BY' ? 2 : 1.5
                        });
                        
                        // Add reverse relationship for certain types
                        if (linkType === 'AUTHORED_BY') {
                            links.push({
                                source: targetId,
                                target: sourceId,
                                type: 'AUTHOR_OF',
                                label: 'author of',
                                strength: 0.9,
                                color: getLinkColor('AUTHOR_OF'),
                                curve: -0.2,
                                width: 2
                            });
                        }
                        
                        // Mark this link as processed
                        linkSet.add(key);
                    }
                });
            }

            return { nodes, links };
        }

        // Update graph with new data and enhanced styling
        function updateGraph({ nodes, links }) {
            console.log('Updating graph with:', { nodes, links });
            
            // Clear previous simulation if exists
            if (window.simulation) {
                window.simulation.stop();
                window.simulation.nodes([]);
            }

            // Ensure nodes have required properties and make available globally
            window.validNodes = (nodes || []).map(node => ({
                id: String(node.id || ''),
                type: node.type || 'UNKNOWN',
                label: node.label || node.title || node.name || String(node.id || '').substring(0, 20) + '...',
                size: node.size || 10,
                group: node.group || (node.type ? node.type.toLowerCase() : 'other'),
                ...node
            }));

            // Ensure links have required properties and resolve node references
            window.validLinks = (links || []).map(link => {
                // Handle both object and ID references for source/target
                const source = link.source?.id || link.source;
                const target = link.target?.id || link.target;
                
                // Check if source and target nodes exist
                const sourceExists = validNodes.some(n => n.id === source);
                const targetExists = validNodes.some(n => n.id === target);
                
                if (!sourceExists || !targetExists) {
                    console.warn('Skipping invalid link - missing node:', { source, target, sourceExists, targetExists });
                    return null;
                }
                
                return {
                    source: source,
                    target: target,
                    type: link.type || 'RELATED_TO',
                    value: link.value || link.strength || 1,
                    strength: link.strength || 0.5,
                    label: link.label || link.type || 'related to'
                };
            }).filter(Boolean); // Remove any null entries from invalid links

            console.log(`Processing ${validNodes.length} nodes and ${validLinks.length} valid links`);

            // Create force simulation
            try {
                window.simulation = d3.forceSimulation(validNodes)
                .force('link', d3.forceLink(validLinks)
                    .id(d => d.id)
                    .distance(d => 150 / (d.strength || 1))  // Stronger connections = shorter distance
                    .strength(d => d.strength || 0.5)
                )
                .force('charge', d3.forceManyBody()
                    .strength(d => {
                        // Adjust repulsion based on node type
                        switch(d.type) {
                            case 'PAPER': return -800;
                            case 'AUTHOR': return -600;
                            case 'CONCEPT': return -400;
                            default: return -300;
                        }
                    })
                )
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide()
                    .radius(d => (d.size || 30) * 1.5)
                    .strength(0.8)
                )
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));

            // Create link elements
            link = g.selectAll('.link')
                .data(validLinks, d => `${d.source.id || d.source}-${d.target.id || d.target}-${d.type}`)
                .join('line')
                .attr('class', 'link')
                .attr('stroke', d => getLinkColor(d.type) || '#999')
                .attr('stroke-width', d => (d.strength || 0.5) * 2)
                .attr('marker-end', d => `url(#arrow-${d.type || 'default'})`);

                // Process and update graph with error handling
                try {
                    const { nodes, links } = processGraphData(graphData);
                    updateGraph({ nodes, links });
                    
                    // Add debug CSS
                    d3.select('head').append('style')
                        .text(`
                            .node {
                                border: 1px solid red;
                            }
                            .link {
                                stroke-width: 2px;
                            }
                        `);

                    // Add debug HTML
                    d3.select('body').append('div')
                        .attr('id', 'debug-info')
                        .html(`
                            <h3>Debug Info</h3>
                            <pre id="debug-data"></pre>
                        `);

                    // Add debug JavaScript
                    d3.select('#debug-info')
                        .on('click', () => {
                            const debugData = {
                                nodes: nodes.map(n => ({ id: n.id, type: n.type })),
                                links: links.map(l => ({ source: l.source, target: l.target, type: l.type }))
                            };
                            d3.select('#debug-data').text(JSON.stringify(debugData, null, 2));
                        });
                } catch (e) {
                    console.error('Error updating graph:', e);
                    d3.select('#graph').html(`
                        <div style="padding: 20px; color: red;">
                            <h3>Graph Update Error</h3>
                            <pre>${e.toString()}</pre>
                            <pre>${e.stack}</pre>
                        </div>
                    `);
                }

                // Process node groups
                const nodeGroups = g.selectAll('.node')
                    .data(validNodes, d => d.id)
                    .join(enter => {
                        const nodeGroup = enter.append('g')
                            .attr('class', 'node')
                            .call(d3.drag()
                                .on('start', dragstarted)
                                .on('drag', dragged)
                                .on('end', dragended)
                            )
                            .on('click', (event, d) => selectNode(d, event))
                            .on('mouseover', showTooltip)
                            .on('mousemove', updateTooltip)
                            .on('mouseout', hideTooltip);
                    
                    // Add circle for each node
                    nodeGroup.append('circle')
                        .attr('r', d => d.size || 10)
                        .attr('fill', d => getNodeColor(d.type) || '#999')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);
                    
                    // Add text label
                    nodeGroup.append('text')
                        .attr('dy', 4)
                        .attr('text-anchor', 'middle')
                        .text(d => d.label || d.id)
                        .attr('fill', '#fff')
                        .attr('font-size', d => Math.max(10, Math.min(14, (d.size || 10) * 0.7)));
                    
                    return nodeGroup;
                }, update => update, exit => exit.remove());
            
            console.log('Node groups created:', nodeGroups.size());

            // Add simulation tick function with error handling
            window.simulation.on('tick', () => {
                try {
                    // Update link positions
                    link
                        .attr('x1', d => d.source?.x || 0)
                        .attr('y1', d => d.source?.y || 0)
                        .attr('x2', d => d.target?.x || 0)
                        .attr('y2', d => d.target?.y || 0);

                    // Update node positions
                    nodeGroups
                        .attr('transform', d => {
                            if (!d || typeof d.x !== 'number' || typeof d.y !== 'number') {
                                console.warn('Invalid node position:', d);
                                return 'translate(0,0)';
                            }
                            return `translate(${d.x},${d.y})`;
                        });
                } catch (error) {
                    console.error('Error in simulation tick:', error);
                }
            });

            // Set up zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Function to zoom to fit all nodes
            function zoomToFit() {
                if (!validNodes.length) return;
                
                // Get bounds of all nodes
                const padding = 50;
                const xExtent = d3.extent(validNodes, d => d.x);
                const yExtent = d3.extent(validNodes, d => d.y);
                const nodeSizes = validNodes.map(d => d.size || 10);
                
                const minX = xExtent[0] - Math.max(...nodeSizes) - padding;
                const maxX = xExtent[1] + Math.max(...nodeSizes) + padding;
                const minY = yExtent[0] - Math.max(...nodeSizes) - padding;
                const maxY = yExtent[1] + Math.max(...nodeSizes) + padding;
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                
                // Calculate scale to fit
                const scale = 0.9 / Math.max(
                    graphWidth / width,
                    graphHeight / height
                );
                
                // Calculate translation
                const translate = [
                    (width / 2) - (scale * midX),
                    (height / 2) - (scale * midY)
                ];
                
                // Apply zoom transform
                svg.transition()
                    .duration(1000)
                    .call(
                        zoom.transform,
                        d3.zoomIdentity
                            .translate(translate[0], translate[1])
                            .scale(scale)
                    );
            }
            
            // Initial zoom to fit after a short delay to allow layout to stabilize
            setTimeout(zoomToFit, 500);

            // Update links with enhanced styling
            link = link
                .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}-${d.type}`)
                .join('line')
                .attr('class', 'link')
                .attr('marker-end', d => `url(#arrow-${d.type || 'default'})`)
                .style('stroke', d => getLinkColor(d.type))
                .style('stroke-width', d => Math.sqrt(d.strength || 1) * 1.5)
                .style('opacity', 0.8);

            // Update nodes with enhanced styling
            node = node
                .data(nodes, d => d.id)
                .join('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Update node circles with gradient and hover effects
            node.selectAll('circle')
                .data([0]) // Keep one circle per node
                .join('circle')
                .attr('r', d => Math.sqrt(d.size || 100) / 2 + 10)
                .style('fill', d => getNodeColor(d.type))
                .style('stroke', d => d3.color(getNodeColor(d.type)).darker(0.5))
                .style('stroke-width', 1.5);

            // Update node text with better styling
            nodeText = nodeText
                .data(nodes, d => d.id)
                .join('text')
                .attr('dy', d => -Math.sqrt(d.size || 100) / 2 - 5)
                .text(d => {
                    const maxLength = 20;
                    return d.label.length > maxLength 
                        ? d.label.substring(0, maxLength) + '...' 
                        : d.label;
                })
                .style('fill', '#2c3e50')
                .style('font-size', '11px')
                .style('font-weight', '500')
                .style('text-anchor', 'middle')
                .style('pointer-events', 'none')
                .style('user-select', 'none');

            // Add tooltip interactions
            node.on('mouseover', showTooltip)
                .on('mousemove', updateTooltip)
                .on('mouseout', hideTooltip)
                .on('click', (event, d) => selectNode(d, event));

            // Initialize simulation with better physics
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => 100 + (d.strength || 1) * 20)
                    .strength(d => 0.8))
                .force('charge', d3.forceManyBody()
                    .strength(d => -300 * (d.size ? Math.sqrt(d.size) / 10 : 1)))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide()
                    .radius(d => Math.sqrt(d.size || 100) + 10))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));

            // Update positions on tick with smooth transitions
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
                nodeText.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Add zoom behavior
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                }));
        }

        // Get color for node based on type
        function getNodeColor(type) {
            return colorScheme[type] || colorScheme.default;
        }
        
        // Get color for link based on relationship type
        function getLinkColor(type) {
            const colors = {
                'CITES': '#ff7f0e',
                'AUTHORED_BY': '#e15759',
                'USES': '#59a14f',
                'COMPARES': '#9467bd',
                'IMPROVES': '#8c564b',
                'INTRODUCES': '#17becf',
                'EVALUATES': '#d62728',
                'DEMONSTRATES': '#bcbd22',
                'ACHIEVES': '#e377c2',
                'BASED_ON': '#7f7f7f',
                'EXTENDS': '#1f77b4',
                'AFFILIATED_WITH': '#ffbb78',
                'PUBLISHED_IN': '#aec7e8',
                'PRESENTS': '#98df8a',
                'ADDRESSES': '#c5b0d5',
                'default': '#c7c7c7'
            };
            return colors[type] || colors.default;
        }

        // Show tooltip and highlight connected nodes/links on hover
        function showTooltip(event, d) {
            // Update tooltip content
            tooltip
                .style('opacity', 1)
                .html(`
                    <h3>${d.label}</h3>
                    <p><span class="type" style="background: ${getNodeColor(d.type)}">${d.type}</span></p>
                    ${d.description ? `<p>${d.description.substring(0, 200)}${d.description.length > 200 ? '...' : ''}</p>` : ''}
                    ${d.citations ? `<p>📚 ${d.citations} citations</p>` : ''}
                    ${d.year ? `<p>📅 ${d.year}</p>` : ''}
                `);
            
            // Highlight connected nodes and links
            const linkedNodes = new Set();
            const linkedLinks = [];
            
            // Find all connected links
            link.each(linkData => {
                if (linkData.source.id === d.id || linkData.target.id === d.id) {
                    linkedLinks.push(linkData);
                    linkedNodes.add(linkData.source.id);
                    linkedNodes.add(linkData.target.id);
                }
            });
            
            // Apply highlight classes
            link.classed('highlighted', linkData => linkedLinks.includes(linkData))
                .classed('faded', linkData => !linkedLinks.includes(linkData));
                
            node.select('circle')
                .classed('highlighted', nodeData => linkedNodes.has(nodeData.id) || nodeData.id === d.id)
                .classed('faded', nodeData => !linkedNodes.has(nodeData.id) && nodeData.id !== d.id);
                
            node.select('text')
                .classed('highlighted', nodeData => linkedNodes.has(nodeData.id) || nodeData.id === d.id)
                .classed('faded', nodeData => !linkedNodes.has(nodeData.id) && nodeData.id !== d.id);
        }

        function updateTooltip(event, d) {
            tooltip
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY + 15) + 'px');
        }

        // Hide tooltip and reset highlights when mouse leaves node
        function hideTooltip() {
            tooltip.style('opacity', 0);
            
            // Reset all highlights
            link.classed('highlighted', false)
                .classed('faded', false);
                
            node.select('circle')
                .classed('highlighted', false)
                .classed('faded', false);
                
            node.select('text')
                .classed('highlighted', false)
                .classed('faded', false);
        }
        
        function selectNode(selectedNode, event) {
            event.stopPropagation();
            
            // Reset all nodes and links
            node.select('circle')
                .classed('selected', false)
                .style('stroke-width', 1.5)
                .style('stroke-opacity', 0.8);
                
            node.select('text')
                .classed('selected', false)
                .style('font-weight', 'normal')
                .style('font-size', '12px');
            
            // If clicking the same node, deselect it
            const isSameNode = window.selectedNode && window.selectedNode.id === selectedNode.id;
            
            if (isSameNode) {
                window.selectedNode = null;
                return;
            }
            
            // Update selected node
            window.selectedNode = selectedNode;
            
            // Highlight selected node
            const selectedElement = d3.select(event.currentTarget);
            selectedElement.select('circle')
                .classed('selected', true)
                .style('stroke-width', 3)
                .style('stroke', '#fff')
                .style('stroke-opacity', 1);
                
            selectedElement.select('text')
                .classed('selected', true)
                .style('font-weight', 'bold')
                .style('font-size', '14px');
            
            // Find connected nodes and links
            const connectedNodeIds = new Set();
            const connectedLinks = [];
            
            link.each(linkData => {
                if (linkData.source.id === selectedNode.id || linkData.target.id === selectedNode.id) {
                    connectedLinks.push(linkData);
                    connectedNodeIds.add(linkData.source.id);
                    connectedNodeIds.add(linkData.target.id);
                    d3.select(`[data-id="${d.id}"] circle`)
                        .style('stroke-width', 3)
                        .style('stroke-opacity', 1);
                }
            });
            
            // Center the view on the selected node
            const transform = d3.zoomTransform(svg.node());
            const x = selectedNode.x || width / 2;
            const y = selectedNode.y || height / 2;
            const scale = 1.5; // Zoom in a bit
            
            svg.transition()
                .duration(750)
                .call(
                    d3.zoom().transform,
                    d3.zoomIdentity
                        .translate(width / 2, height / 2)
                        .scale(scale)
                        .translate(-x, -y)
                );
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Initialize the graph
        initGraph();
        
        // Get paperId from template variable
        const paperId = '{{ paper_id }}';
        
        if (paperId) {
            // Show loading state
            d3.select('#graph').html(`
                <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
                    <div style="text-align: center;">
                        <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading knowledge graph for paper ${paperId}...</p>
                    </div>
                </div>
            `);
            
            // Load the paper graph
            loadPaperGraph(paperId);
        } else {
            // Show error if no paperId is provided
            d3.select('#graph').html(`
                <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
                    <div class="alert alert-danger">
                        <h4>Error</h4>
                        <p>No paper ID provided. Please go back and try again.</p>
                        <button class="btn btn-primary mt-2" onclick="window.history.back()">Go Back</button>
                    </div>
                </div>
            `);
        }
        
        // Zoom and reset controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            const currentTransform = d3.zoomTransform(svg.node());
            const newScale = Math.min(currentTransform.k * 1.2, 4); // Limit max zoom
            svg.transition().duration(200).call(
                d3.zoom().transform,
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
            const currentTransform = d3.zoomTransform(svg.node());
            const newScale = Math.max(currentTransform.k / 1.2, 0.1); // Limit min zoom
            svg.transition().duration(200).call(
                d3.zoom().transform,
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
        });
        
        document.getElementById('reset-view').addEventListener('click', () => {
            svg.call(zoom);

            // Function to zoom to fit all nodes
            function zoomToFit() {
                if (validNodes.length === 0) return;
                
                // Get bounds of all nodes
                const padding = 100; // Padding around the nodes
                const bounds = d3.extent(validNodes, d => d.x - (d.size || 10))
                    .concat(d3.extent(validNodes, d => d.x + (d.size || 10)))
                    .concat(d3.extent(validNodes, d => d.y - (d.size || 10)))
                    .concat(d3.extent(validNodes, d => d.y + (d.size || 10)));
                
                const minX = bounds[0] - padding;
                const maxX = bounds[1] + padding;
                const minY = bounds[2] - padding;
                const maxY = bounds[3] + padding;
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                const scale = Math.min(8, 0.9 / Math.max(graphWidth / width, graphHeight / height));
                
                // Calculate center
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                
                // Apply zoom transform
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(scale)
                    .translate(-midX, -midY);
                
                svg.transition()
                    .duration(1000)
                    .call(zoom.transform, transform);
            }

            // Initial zoom to fit with error handling
            try {
                setTimeout(() => {
                    try {
                        zoomToFit();
                    } catch (e) {
                        console.error('Error in zoomToFit:', e);
                    }
                }, 500);
                
                // Update debug info periodically
                setInterval(updateDebugInfo, 1000);
                updateDebugInfo();
                
            } catch (e) {
                console.error('Error in initialization:', e);
                d3.select('#graph').html(`
                    <div style="padding: 20px; color: red;">
                        <h3>Initialization Error</h3>
                        <pre>${e.toString()}</pre>
                        <pre>${e.stack}</pre>
                    </div>
                `);
            }

            // Reset zoom button
            d3.select('#reset-zoom').on('click', () => {
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            });    
            // Clear any selections
            if (window.selectedNode) {
                node.select('circle').classed('selected', false);
                node.select('text').classed('selected', false);
                window.selectedNode = null;
            }
            
            // Reset all nodes and links to full opacity
            node.select('circle').style('opacity', 1);
            node.select('text').style('opacity', 1);
            link.style('opacity', 1);
        });
        
        document.getElementById('fit-view').addEventListener('click', () => {
            if (!graphData.nodes || graphData.nodes.length === 0) return;
            
            // Get bounds of all nodes
            const xExtent = d3.extent(graphData.nodes, d => d.x);
            const yExtent = d3.extent(graphData.nodes, d => d.y);
            
            // Calculate dimensions with padding
            const padding = 100;
            const width = xExtent[1] - xExtent[0] + padding * 2;
            const height = yExtent[1] - yExtent[0] + padding * 2;
            const midX = (xExtent[0] + xExtent[1]) / 2;
            const midY = (yExtent[0] + yExtent[1]) / 2;
            
            // Calculate scale and translation
            const scale = Math.min(
                4, // Max scale
                (svg.attr('width') - padding * 2) / width,
                (svg.attr('height') - padding * 2) / height
            ) * 0.9; // 90% of available space
            
            const translate = [
                svg.attr('width') / 2 - scale * midX,
                svg.attr('height') / 2 - scale * midY
            ];
            
            // Apply the transform
            svg.transition()
                .duration(750)
                .call(
                    d3.zoom().transform,
                    d3.zoomIdentity
                        .translate(translate[0], translate[1])
                        .scale(scale)
                );
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            svg.attr('width', newWidth)
               .attr('height', newHeight);
            
            // Re-center the graph
            if (window.simulation) {
                window.simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
                window.simulation.alpha(0.3).restart();
            }
        });
    </script>
</body>
</html>
