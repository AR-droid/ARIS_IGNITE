<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Molecule Viewer - {{ molecule_title }}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; overflow: hidden; color: #E5E7EB; }
        .sidebar { transition: transform 0.3s ease-in-out, width 0.3s ease-in-out; will-change: transform, width; background-color: #1F2937; }
        .sidebar-left.hidden { transform: translateX(-100%); width: 0; }
        .toggle-btn { position: absolute; top: 50%; transform: translateY(-50%); background-color: #374151; border: 1px solid #4B5563; width: 24px; height: 48px; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; color: #D1D5DB; }
        .toggle-left { right: -24px; border-radius: 0 8px 8px 0; }
        button { background-color: #4B5563; color: #D1D5DB; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s; cursor: pointer; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        button:hover { background-color: #6B7280; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }

        #atom-tooltip {
            position: absolute;
            background-color: #2D3748; /* bg-gray-700 */
            color: #E2E8F0; /* text-gray-200 */
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.8em;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid #4A5568; /* border-gray-600 */
        }
        #atom-tooltip.visible {
            opacity: 1;
        }
    </style>
    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/" } }
    </script>
</head>
<body class="bg-gray-900 text-gray-100 flex h-screen text-sm">

    <div id="left-sidebar" class="sidebar sidebar-left w-80 flex-shrink-0 relative z-20 shadow-lg">
        <div class="p-4 flex flex-col h-full overflow-y-auto">
            <h1 class="text-xl font-bold mb-2 text-center text-blue-400">3D Molecule Viewer</h1>
            <h2 class="text-md mb-4 text-center text-gray-300 truncate" title="{{ molecule_title }}">{{ molecule_title }}</h2>
            <div class="mb-6">
                <h2 class="text-md font-semibold mb-2 text-gray-300">Global Settings</h2>
                <div class="bg-gray-700 p-3 rounded-md space-y-2 text-xs">
                    <div class="flex justify-between items-center"><label>Grid Visibility</label><input id="grid-toggle" type="checkbox" checked onchange="toggleGrid(this.checked)"></div>
                </div>
            </div>
            <div class="mb-6">
                <h2 class="text-md font-semibold mb-2 text-gray-300">Camera Controls</h2>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <button onclick="setCameraView('top')">Top</button>
                    <button onclick="setCameraView('front')">Front</button>
                    <button onclick="setCameraView('side')">Side</button>
                    <button onclick="setCameraView('default')">Reset</button>
                </div>
            </div>
            <div class="mt-auto space-y-4 pt-4 border-t border-gray-700">
                <div class="w-full">
                    <h2 class="text-md font-semibold mb-2 text-gray-300">Generate Scientific Model âœ¨</h2>
                    <div class="bg-gray-700 p-3 rounded-md flex flex-col space-y-2 text-xs">
                        <textarea id="prompt-input" rows="3" placeholder="e.g., Acetic acid, caffeine, benzene..." class="w-full text-gray-100 p-2 rounded-md bg-gray-600 border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500 resize-none"></textarea>
                        <button id="generate-button" onclick="generateModelFromPrompt()" class="bg-indigo-600 hover:bg-indigo-500">Generate Model</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="left-toggle" class="toggle-btn toggle-left" onclick="toggleLeftPanel()"><span id="left-toggle-icon">&lt;</span></div>
    </div>

    <div id="canvas-container" class="flex-1 relative bg-gray-900 overflow-hidden">
        <canvas id="canvas-3d"></canvas>
        <div id="message-box" class="absolute top-4 left-1/2 -translate-x-1/2 bg-gray-800 text-blue-400 px-4 py-2 rounded-md shadow-lg hidden z-50"></div>
        <div id="renderer" class="flex-1 relative">
            <div class="absolute top-4 right-4 z-10">
                <button onclick="window.close()" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 shadow-lg">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
        </div>
        <div id="atom-tooltip" class="hidden"></div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, orbitControls, gridHelper;
        let raycaster, mouse;
        let INTERSECTED; 
        const atomTooltip = document.getElementById('atom-tooltip');

        const canvasContainer = document.getElementById('canvas-container');

        const CPK_COLORS = { 
            'H': 0xFFFFFF, 'C': 0x282828, 'N': 0x0000FF, 'O': 0xFF0000,
            'F': 0x90E050, 'CL': 0x90E050, 'BR': 0xA52A2A, 'I': 0x9400D3,
            'P': 0xFFA500, 'S': 0xFFFF00, 'B': 0xFA8072, 'LI': 0xCC8899,
            'NA': 0xAA66FF, 'K': 0x6633AA, 'MG': 0x008000, 'CA': 0x808090,
            'FE': 0xA0522D, 'DEFAULT': 0xFFC0CB 
        };
        const ATOM_RADII = { 'H': 0.25, 'DEFAULT': 0.4 };

        const ATOMIC_PROPERTIES = {
            'H': { name: 'Hydrogen', atomicNumber: 1, atomicMass: 1.008 },
            'C': { name: 'Carbon', atomicNumber: 6, atomicMass: 12.011 },
            'N': { name: 'Nitrogen', atomicNumber: 7, atomicMass: 14.007 },
            'O': { name: 'Oxygen', atomicNumber: 8, atomicMass: 15.999 },
            'F': { name: 'Fluorine', atomicNumber: 9, atomicMass: 18.998 },
            'CL': { name: 'Chlorine', atomicNumber: 17, atomicMass: 35.453 },
            'BR': { name: 'Bromine', atomicNumber: 35, atomicMass: 79.904 },
            'I': { name: 'Iodine', atomicNumber: 53, atomicMass: 126.904 },
            'P': { name: 'Phosphorus', atomicNumber: 15, atomicMass: 30.974 },
            'S': { name: 'Sulfur', atomicNumber: 16, atomicMass: 32.06 },
            'B': { name: 'Boron', atomicNumber: 5, atomicMass: 10.81 },
            'LI': { name: 'Lithium', atomicNumber: 3, atomicMass: 6.94 },
            'NA': { name: 'Sodium', atomicNumber: 11, atomicMass: 22.990 },
            'K': { name: 'Potassium', atomicNumber: 19, atomicMass: 39.098 },
            'MG': { name: 'Magnesium', atomicNumber: 12, atomicMass: 24.305 },
            'CA': { name: 'Calcium', atomicNumber: 20, atomicMass: 40.078 },
            'FE': { name: 'Iron', atomicNumber: 26, atomicMass: 55.845 },
            'DEFAULT': { name: 'Unknown Atom', atomicNumber: '?', atomicMass: '?' }
        };

        function showMessage(message, duration = 3000) {
            const box = document.getElementById('message-box');
            box.textContent = message;
            box.classList.remove('hidden');
            setTimeout(() => box.classList.add('hidden'), duration);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            const { clientWidth: width, clientHeight: height } = canvasContainer;
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(5, 5, 5);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas-3d'), antialias: true });
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0x888888));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 5, 10);
            scene.add(dirLight);
            gridHelper = new THREE.GridHelper(20, 20, 0x4B5563, 0x4B5563);
            scene.add(gridHelper);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', onMouseMove);

            window.addEventListener('resize', onWindowResize);
            onWindowResize();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            checkIntersections(); 
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const { clientWidth: width, clientHeight: height } = canvasContainer;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function onMouseMove(event) {
            const canvasRect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
            mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;

            atomTooltip.style.left = `${event.clientX + 15}px`;
            atomTooltip.style.top = `${event.clientY + 15}px`;
        }

        function checkIntersections() {
            if (!scene || !raycaster || !camera) return;

            raycaster.setFromCamera(mouse, camera);

            const moleculeGroup = scene.getObjectByName("molecule");
            const atomMeshes = moleculeGroup ? moleculeGroup.children.filter(obj => obj.isMesh && obj.geometry.type === 'SphereGeometry') : [];
            const intersects = raycaster.intersectObjects(atomMeshes, true);

            if (intersects.length > 0) {
                if (INTERSECTED != intersects[0].object) {
                    INTERSECTED = intersects[0].object;
                    
                    if (INTERSECTED.userData.atomicProperties) {
                        const props = INTERSECTED.userData.atomicProperties;
                        atomTooltip.innerHTML = `
                            <strong>${props.name} (${props.symbol})</strong><br>
                            Atomic No: ${props.atomicNumber}<br>
                            Mass: ${props.atomicMass}
                        `;
                        atomTooltip.classList.remove('hidden');
                        setTimeout(() => atomTooltip.classList.add('visible'), 10);
                    }
                }
            } else {
                if (INTERSECTED) {
                    INTERSECTED = null;
                    atomTooltip.classList.remove('visible');
                    setTimeout(() => atomTooltip.classList.add('hidden'), 200); 
                }
            }
        }

        const GEMINI_API_KEY = "AIzaSyDt7Jtx8tCFmIzq5iEKfLVRz6lmpj7_Q38"; // Ensure this is correct
    

        const MODEL_GENERATION_SYSTEM_PROMPT = `You are an expert computational chemist. Your task is to receive the name of a chemical molecule and return its 3D atomic coordinates, bond information, and basic atomic properties.
        The output must be in three parts.
        First, the standard PDB format, ending with an END record.
        Second, immediately following the PDB data, add a custom section starting with "---BONDS---" that lists the bond orders for connected atoms.
        Third, immediately following the BONDS section, add a custom section starting with "---PROPERTIES---" that lists properties for each atom.

        - Your output MUST be ONLY the raw text. Do not include any explanations or markdown.
        - The BONDS section should list pairs of 1-based atom indices followed by the bond type (SINGLE, DOUBLE, TRIPLE, AROMATIC).
        - The PROPERTIES section should list 1-based atom index, followed by the full element name, atomic number, and atomic mass.

        Example for "water":
        ATOM      1  O   UNL     1       0.000   0.000   0.000
        ATOM      2  H   UNL     1       0.757   0.586   0.000
        ATOM      3  H   UNL     1      -0.757   0.586   0.000
        CONECT    1    2    3
        CONECT    2    1
        CONECT    3    1
        END
        ---BONDS---
        1 2 SINGLE
        1 3 SINGLE
        ---PROPERTIES---
        1 Oxygen 8 15.999
        2 Hydrogen 1 1.008
        3 Hydrogen 1 1.008
        `;

        window.generateModelFromPrompt = async function() {
            const userPrompt = document.getElementById('prompt-input').value.trim();
            if (!userPrompt) return showMessage("Please enter a molecule name.");
            if (GEMINI_API_KEY === "YOUR_GEMINI_API_KEY") return showMessage("Please enter your Gemini API Key in the code.");
            
            const generateButton = document.getElementById('generate-button');
            generateButton.disabled = true;
            generateButton.textContent = "Generating...";

            try {
                showMessage("Requesting PDB data from AI...");
                const payload = { contents: [{ parts: [{ text: userPrompt }] }], systemInstruction: { parts: [{ text: MODEL_GENERATION_SYSTEM_PROMPT }] } };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorResponse.error.message || response.statusText}`);
                }
                
                const result = await response.json();
                const fullText = result.candidates[0].content.parts[0].text;
                
                showMessage("Parsing data and building model...");
                loadMoleculeFromPDB(fullText);

            } catch (e) {
                console.error("Error generating model:", e);
                showMessage(`Error: ${e.message}`, 7000);
            } finally {
                generateButton.disabled = false;
                generateButton.textContent = "Generate Model";
            }
        };

        // --- NEW: Function to create a material with an integrated label ---
        function createAtomMaterialWithLabel(elementSymbol, baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Smaller canvas for efficiency, but still enough resolution
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Draw background color (matching the atom's base color)
            context.fillStyle = `#${baseColor.toString(16).padStart(6, '0')}`;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw text
            context.font = 'bold 60px Arial'; 
            context.fillStyle = (baseColor === 0xFFFFFF || baseColor === 0xFFFF00) ? 'black' : 'white'; // Black text for light atoms (H, S), white for dark
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(elementSymbol, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            // texture.needsUpdate = true; // Not strictly needed if only created once

            return new THREE.MeshStandardMaterial({ 
                color: baseColor, 
                map: texture,
                transparent: true // Might need for text to appear clean
            });
        }
        
        function loadMoleculeFromPDB(fullText) {
            const oldMolecule = scene.getObjectByName("molecule");
            if (oldMolecule) scene.remove(oldMolecule);

            const moleculeGroup = new THREE.Group();
            moleculeGroup.name = "molecule";

            const parts = fullText.split('---BONDS---');
            const pdbText = parts[0];
            const bondTextAndProperties = parts[1] || '';
            
            const bondParts = bondTextAndProperties.split('---PROPERTIES---');
            const bondText = bondParts[0];
            const propertiesText = bondParts[1] || '';

            const lines = pdbText.split('\n');
            const atoms = {}; 
            const bondOrders = {}; 
            const atomProperties = {}; 

            if (bondText) {
                bondText.trim().split('\n').forEach(line => {
                    const [idx1, idx2, type] = line.trim().split(/\s+/);
                    const key = `${Math.min(idx1, idx2)}-${Math.max(idx1, idx2)}`;
                    bondOrders[key] = type;
                });
            }

            if (propertiesText) {
                propertiesText.trim().split('\n').forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 4) { // Ensure enough data
                        const index = parseInt(parts[0]);
                        const name = parts[1];
                        const atomicNumber = parseInt(parts[2]);
                        const atomicMass = parseFloat(parts[3]);
                        atomProperties[index] = { name, atomicNumber, atomicMass };
                    }
                });
            }

            lines.forEach(line => {
                if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
                    const index = parseInt(line.substring(6, 11));
                    // Extract element symbol from PDB: typically cols 77-78 or 13-16 (atom name)
                    let elementSymbol = line.substring(76, 78).trim().toUpperCase(); 

                    // Fallback to ATOM name if element field is empty or generic
                    if (elementSymbol === '' || elementSymbol === 'X' || elementSymbol.length > 2) {
                        elementSymbol = line.substring(12, 16).trim().replace(/[^A-Za-z]/g, '').toUpperCase();
                    }
                    // Further fallback/correction using properties if available
                    if (atomProperties[index] && atomProperties[index].name) {
                        const propName = atomProperties[index].name.toUpperCase();
                        // Try to derive symbol from name (e.g., "CARBON" -> "C")
                        // This is a simplification; a full lookup table is better.
                        const derivedSymbol = Object.keys(ATOMIC_PROPERTIES).find(key => ATOMIC_PROPERTIES[key].name.toUpperCase() === propName);
                        if (derivedSymbol) {
                            elementSymbol = derivedSymbol;
                        } else if (propName.startsWith('HYDR')) { // Heuristic for Hydrogen
                            elementSymbol = 'H';
                        } else if (propName.startsWith('OXYG')) { // Heuristic for Oxygen
                            elementSymbol = 'O';
                        } else if (propName.startsWith('NITR')) { // Heuristic for Nitrogen
                            elementSymbol = 'N';
                        } else if (propName.startsWith('CARB')) { // Heuristic for Carbon
                            elementSymbol = 'C';
                        }
                    }
                     // Final check to ensure it's a known symbol
                    if (!CPK_COLORS[elementSymbol]) {
                        elementSymbol = 'DEFAULT';
                    }

                    const x = parseFloat(line.substring(30, 38));
                    const y = parseFloat(line.substring(38, 46));
                    const z = parseFloat(line.substring(46, 54));
                    
                    const baseColor = CPK_COLORS[elementSymbol] || CPK_COLORS['DEFAULT'];
                    const radius = ATOM_RADII[elementSymbol] || ATOM_RADII['DEFAULT'];

                    // --- NEW: Use new function to create material with integrated label ---
                    const atomMaterial = createAtomMaterialWithLabel(elementSymbol, baseColor);
                    const atomMesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), atomMaterial); // Increased segments for smoother sphere
                    atomMesh.position.set(x, y, z);
                    
                    atomMesh.userData.isAtom = true;
                    atomMesh.userData.atomicProperties = {
                        symbol: elementSymbol,
                        name: atomProperties[index] ? atomProperties[index].name : ATOMIC_PROPERTIES[elementSymbol] ? ATOMIC_PROPERTIES[elementSymbol].name : 'Unknown',
                        atomicNumber: atomProperties[index] ? atomProperties[index].atomicNumber : ATOMIC_PROPERTIES[elementSymbol] ? ATOMIC_PROPERTIES[elementSymbol].atomicNumber : '?',
                        atomicMass: atomProperties[index] ? atomProperties[index].atomicMass : ATOMIC_PROPERTIES[elementSymbol] ? ATOMIC_PROPERTIES[elementSymbol].atomicMass : '?'
                    };

                    moleculeGroup.add(atomMesh);
                    
                    atoms[index] = { position: atomMesh.position, element: elementSymbol }; 
                }
            });

            lines.forEach(line => {
                if (line.startsWith('CONECT')) {
                    const indices = line.substring(6).trim().split(/\s+/).map(Number);
                    const fromIndex = indices[0];
                    if (!atoms[fromIndex]) return;
                    for (let i = 1; i < indices.length; i++) {
                        const toIndex = indices[i];
                        if (toIndex < fromIndex || !atoms[toIndex]) continue;
                        const key = `${fromIndex}-${toIndex}`;
                        const order = bondOrders[key] || 'SINGLE';
                        createBond(atoms[fromIndex].position, atoms[toIndex].position, order, moleculeGroup);
                    }
                }
            });
            
            orientMolecule(moleculeGroup);
            scene.add(moleculeGroup);
            frameSceneContent(moleculeGroup);
        }

        function createBond(start, end, order, group) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            const material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const radius = 0.08;
            const offsetDist = 0.12;

            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction.clone().normalize());

            const addCylinder = (offset) => {
                const geo = new THREE.CylinderGeometry(radius, radius, length, 8);
                const mesh = new THREE.Mesh(geo, material);
                mesh.setRotationFromQuaternion(quaternion);
                mesh.position.copy(start).add(direction.clone().multiplyScalar(0.5)).add(offset);
                group.add(mesh);
            };

            let offsetVec = new THREE.Vector3();
            if (order !== 'SINGLE') {
                offsetVec.crossVectors(direction, up).normalize().multiplyScalar(offsetDist);
                 if(offsetVec.length() < 0.01) { // Fallback if direction and up are parallel
                    offsetVec.crossVectors(direction, new THREE.Vector3(1,0,0)).normalize().multiplyScalar(offsetDist);
                }
            }
            
            if (order === 'SINGLE') addCylinder(new THREE.Vector3(0,0,0));
            else if (order === 'DOUBLE' || order === 'AROMATIC') {
                addCylinder(offsetVec.clone().multiplyScalar(0.5));
                addCylinder(offsetVec.clone().multiplyScalar(-0.5));
            } else if (order === 'TRIPLE') {
                addCylinder(new THREE.Vector3(0,0,0));
                addCylinder(offsetVec);
                addCylinder(offsetVec.clone().multiplyScalar(-1));
            }
        }

        function orientMolecule(moleculeGroup) {
            const positions = [];
            moleculeGroup.traverse(child => {
                if (child.isMesh && child.geometry.type === 'SphereGeometry') {
                    positions.push(child.position);
                }
            });

            if (positions.length < 2) return;

            let maxDistSq = 0;
            let atomA = positions[0], atomB = positions[1];
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    const distSq = positions[i].distanceToSquared(positions[j]);
                    if (distSq > maxDistSq) {
                        maxDistSq = distSq;
                        atomA = positions[i];
                        atomB = positions[j];
                    }
                }
            }

            const box = new THREE.Box3().setFromObject(moleculeGroup);
            const center = box.getCenter(new THREE.Vector3());
            moleculeGroup.position.sub(center); 

            const longestAxis = new THREE.Vector3().subVectors(atomB, atomA).normalize();
            const targetAxis = new THREE.Vector3(1, 0, 0); // Align with X-axis
            const quaternion = new THREE.Quaternion().setFromUnitVectors(longestAxis, targetAxis);
            
            moleculeGroup.applyQuaternion(quaternion);

            const newCenter = new THREE.Box3().setFromObject(moleculeGroup).getCenter(new THREE.Vector3());
            moleculeGroup.position.sub(newCenter);
        }

        function frameSceneContent(targetObject) {
            if (!targetObject) return;
            const box = new THREE.Box3().setFromObject(targetObject);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.8;
            camera.position.set(0, 0, Math.max(cameraZ, 5));
            orbitControls.target.set(0,0,0);
            orbitControls.update();
        }

        window.toggleLeftPanel = () => { document.getElementById('left-sidebar').classList.toggle('hidden'); setTimeout(onWindowResize, 310); };
        window.toggleGrid = (visible) => { gridHelper.visible = visible; };
        window.setCameraView = (view) => {
            orbitControls.reset();
            const pos = { top: [0, 10, 0], front: [0, 0, 10], side: [10, 0, 0], default: [5, 5, 5] };
            camera.position.set(...pos[view]);
            orbitControls.target.set(0, 0, 0);
        };

        window.onload = init;
    </script>
</body>
</html>