import os
import re
import json
import pandas as pd
from pylatex import Document, Section, Subsection, Command, Tabular, Figure, NewPage
from pylatex.utils import NoEscape, escape_latex
import matplotlib.pyplot as plt
import tempfile
import base64
from typing import Dict, List, Optional, Union

class LatexGenerator:
    def __init__(self):
        self.doc = Document(documentclass='article')
        self._setup_document()
    
    def _setup_document(self):
        """Basic LaTeX document setup with common packages."""
        self.doc.preamble.append(Command('title', 'Research Notes'))
        self.doc.preamble.append(Command('author', 'Generated by ARIS IGNITE'))
        self.doc.preamble.append(Command('date', NoEscape(r'\today')))
        self.doc.append(NoEscape(r'\maketitle'))
        
        # Add common packages
        self.doc.preamble.append(Command('usepackage', 'amsmath'))
        self.doc.preamble.append(Command('usepackage', 'graphicx'))
        self.doc.preamble.append(Command('usepackage', 'booktabs'))
        self.doc.preamble.append(Command('usepackage', 'hyperref'))
        self.doc.preamble.append(Command('usepackage', 'geometry', 
                                       options=['a4paper', 'margin=1in']))
    
    def add_section(self, title: str, content: str):
        """Add a new section to the document."""
        with self.doc.create(Section(title)):
            self.doc.append(NoEscape(self._process_content(content)))
    
    def add_equation(self, equation: str, inline: bool = False):
        """Add a mathematical equation."""
        if inline:
            self.doc.append(NoEscape(f"${equation}$"))
        else:
            self.doc.append(NoEscape(f"\\[{equation}\\]"))
    
    def add_table(self, data: Union[List[dict], str], caption: str = None):
        """
        Add a table from data (list of dicts or CSV string).
        If CSV string is provided, it will be converted to a pandas DataFrame.
        """
        if isinstance(data, str):
            # Handle CSV string
            try:
                df = pd.read_csv(data)
                data = df.to_dict('records')
                if df.columns[0].startswith('Unnamed:'):
                    # Handle case where CSV has no header
                    data = [dict(zip(df.columns, row)) for row in df.values]
            except Exception as e:
                raise ValueError(f"Failed to parse CSV data: {str(e)}")
        
        if not data:
            return
            
        # Extract column names from the first row
        columns = list(data[0].keys())
        
        # Create table
        with self.doc.create(Figure(position='h!')) as table:
            if caption:
                table.add_caption(caption)
            
            # Create tabular
            tabular = Tabular('l' * len(columns))
            tabular.add_hline()
            
            # Add header
            tabular.add_row([NoEscape(f'\\textbf{{{escape_latex(str(col))}}}') for col in columns])
            tabular.add_hline()
            
            # Add data rows
            for row in data:
                tabular.add_row([str(row.get(col, '')) for col in columns])
            
            tabular.add_hline()
            self.doc.append(tabular)
    
    def add_chart(self, data: dict, chart_type: str = 'line', 
                 x_label: str = '', y_label: str = '', title: str = ''):
        """
        Add a chart from data.
        
        Args:
            data: Dict with 'x' and 'y' keys for data points
            chart_type: Type of chart ('line', 'bar', 'scatter', 'histogram')
            x_label: Label for x-axis
            y_label: Label for y-axis
            title: Chart title
        """
        with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
            try:
                plt.figure()
                
                if chart_type == 'line':
                    plt.plot(data.get('x', []), data.get('y', []))
                elif chart_type == 'bar':
                    plt.bar(data.get('x', []), data.get('y', []))
                elif chart_type == 'scatter':
                    plt.scatter(data.get('x', []), data.get('y', []))
                elif chart_type == 'histogram':
                    plt.hist(data.get('values', []), bins=data.get('bins', 10))
                
                if x_label:
                    plt.xlabel(x_label)
                if y_label:
                    plt.ylabel(y_label)
                if title:
                    plt.title(title)
                
                plt.tight_layout()
                plt.savefig(tmp.name, dpi=300, bbox_inches='tight')
                plt.close()
                
                # Add the image to LaTeX
                with self.doc.create(Figure(position='h!')) as plot:
                    plot.add_image(tmp.name, width=NoEscape(r'\textwidth'))
                    if title:
                        plot.add_caption(title)
                        
            except Exception as e:
                raise ValueError(f"Failed to generate chart: {str(e)}")
            finally:
                try:
                    os.unlink(tmp.name)
                except:
                    pass
    
    def add_page_break(self):
        """Add a page break."""
        self.doc.append(NewPage())
    
    def generate_pdf(self, filename: str):
        """Generate a PDF file from the LaTeX document."""
        self.doc.generate_pdf(filename, clean_tex=True)
    
    def generate_tex(self) -> str:
        """Generate the LaTeX source code."""
        return self.doc.dumps()
    
    def _process_content(self, content: str) -> str:
        """Process content to handle special LaTeX characters and formatting."""
        # Escape special LaTeX characters
        replacements = {
            '&': '\\&',
            '%': '\\%',
            '$': '\\$',
            '#': '\\#',
            '_': '\\_',
            '{': '\\{',
            '}': '\\}',
            '~': '\\textasciitilde{}',
            '^': '\\textasciicircum{}',
            '\\': '\\textbackslash{}',
        }
        
        for orig, repl in replacements.items():
            content = content.replace(orig, repl)
        
        # Handle newlines
        content = content.replace('\n', '\n\\\\\\')
        
        return content


def latex_to_pdf(latex_content: str, output_file: str):
    """Convert LaTeX content to PDF using pandoc."""
    import subprocess
    import tempfile
    
    with tempfile.NamedTemporaryFile(suffix='.tex', mode='w', delete=False) as f:
        f.write(latex_content)
        tex_file = f.name
    
    try:
        subprocess.run(
            ['pandoc', tex_file, '-o', output_file, '--pdf-engine=xelatex'],
            check=True
        )
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error generating PDF: {e}")
        return False
    finally:
        try:
            os.unlink(tex_file)
        except:
            pass

def convert_natural_language_to_latex(text: str) -> str:
    """
    Convert natural language descriptions of equations to LaTeX format.
    This is a simple implementation that can be enhanced with more complex patterns.
    """
    # Simple patterns to LaTeX
    patterns = [
        (r'squared', '^2'),
        (r'cubed', '^3'),
        (r'square root of (.+?)', r'\\sqrt{\1}'),
        (r'sqrt of (.+?)', r'\\sqrt{\1}'),
        (r'pi', r'\\pi'),
        (r'theta', r'\\theta'),
        (r'sigma', r'\\sigma'),
        (r'alpha', r'\\alpha'),
        (r'beta', r'\\beta'),
        (r'gamma', r'\\gamma'),
        (r'delta', r'\\delta'),
        (r'epsilon', r'\\epsilon'),
        (r'integral', r'\\int'),
        (r'sum', r'\\sum'),
        (r'product', r'\\prod'),
        (r'fraction (.+?) over (.+?)', r'\\frac{\1}{\2}'),
        (r'(.+?) over (.+?)', r'\\frac{\1}{\2}'),
    ]
    
    for pattern, replacement in patterns:
        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
    
    return text

def generate_latex_from_json(data: dict) -> str:
    """
    Generate LaTeX from a structured JSON object.
    
    Args:
        data: Dictionary containing document structure and content
            Example:
            {
                'title': 'Document Title',
                'sections': [
                    {
                        'title': 'Section 1',
                        'content': 'Section content...',
                        'type': 'text'
                    },
                    {
                        'type': 'equation',
                        'content': 'E = mc^2',
                        'inline': False
                    },
                    {
                        'type': 'table',
                        'data': [
                            {'col1': 'val1', 'col2': 'val2'},
                            {'col1': 'val3', 'col2': 'val4'}
                        ],
                        'caption': 'Sample Table'
                    },
                    {
                        'type': 'chart',
                        'chart_type': 'line',
                        'data': {'x': [1,2,3], 'y': [2,4,1]},
                        'title': 'Sample Chart',
                        'x_label': 'X',
                        'y_label': 'Y'
                    }
                ]
            }
    """
    generator = LatexGenerator()
    
    # Set document title if provided
    if 'title' in data:
        generator.doc.title = data['title']
    
    # Add sections and content
    if 'sections' in data and isinstance(data['sections'], list):
        for section in data['sections']:
            if not isinstance(section, dict):
                continue
                
            section_type = section.get('type', 'text')
            
            if section_type == 'text':
                generator.add_section(
                    section.get('title', 'Untitled Section'),
                    section.get('content', '')
                )
            elif section_type == 'equation':
                generator.add_equation(
                    section.get('content', ''),
                    section.get('inline', False)
                )
            elif section_type == 'table':
                generator.add_table(
                    section.get('data', []),
                    section.get('caption', '')
                )
            elif section_type == 'chart':
                generator.add_chart(
                    section.get('data', {}),
                    section.get('chart_type', 'line'),
                    section.get('x_label', ''),
                    section.get('y_label', ''),
                    section.get('title', '')
                )
            elif section_type == 'page_break':
                generator.add_page_break()
    
    return generator.generate_tex()
